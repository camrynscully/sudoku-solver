# CISC 681 - Programming Assignment 2
# Camryn Scully

# Parts 1-5: Contains the main functions to solve both 4x4 and 9x9 sudoku puzzles
# -----------------------------------------------------------------------------------------------------------------

from typing import Tuple
from constraints4x4 import constraints4x4
from collections import deque
from copy import deepcopy

# provided sudoku board examples
assignments44 = {'1,1': 1, '2,2': 2, '3,3': 3, '4,4': 4}

assignments1 = {'1,1': 7, '1,4': 4, '1,8': 8, '1,9': 6,
                '2,2': 5, '2,3': 1, '2,5': 8, '2,7': 4,
                '3,2': 4, '3,4': 3, '3,6': 7, '3,8': 9,
                '4,1': 3, '4,3': 9, '4,6': 6, '4,7': 1,
                '5,5': 2,
                '6,3': 4, '6,4': 9, '6,7': 7, '6,9': 8,
                '7,2': 8, '7,4': 1, '7,6': 2, '7,8': 6,
                '8,3': 6, '8,5': 5, '8,7': 9, '8,8': 1,
                '9,1': 2, '9,2': 1, '9,6': 3, '9,9': 5}

assignments2 = {'1,1': 1, '1,4': 2, '1,6': 3, '1,7': 8,
                '2,2': 8, '2,3': 2, '2,5': 6, '2,7': 1,
                '3,1': 7, '3,6': 1, '3,7': 6, '3,8': 4,
                '4,1': 3, '4,5': 9, '4,6': 5, '4,8': 2,
                '5,2': 7, '5,8': 1,
                '6,2': 9, '6,4': 3, '6,5': 1, '6,9': 6,
                '7,2': 5, '7,3': 3, '7,4': 6, '7,9': 1,
                '8,3': 7, '8,5': 2, '8,7': 3, '8,8': 9,
                '9,3': 4, '9,4': 1, '9,6': 9, '9,9': 5}

assignments3 = {'1,1': 1, '1,4': 8, '1,5': 4, '1,8': 5,
                '2,1': 5, '2,4': 9, '2,7': 8, '2,9': 3,
                '3,1': 7, '3,5': 6, '3,7': 1,
                '4,2': 1, '4,4': 5, '4,6': 2, '4,8': 3,
                '5,2': 7, '5,3': 5, '5,7': 2, '5,8': 6,
                '6,2': 3, '6,4': 6, '6,6': 9, '6,8': 4,
                '7,3': 7, '7,5': 5, '7,9': 6,
                '8,1': 4, '8,3': 1, '8,6': 6, '8,9': 7,
                '9,2': 6, '9,5': 9, '9,6': 4, '9,9': 2}

## Part 1 : Representing 4x4 Sudoku as a Binary Constraint Satisfaction Problem (CSP)
##          Utilizes a dictionary to store the variables, domains, and constraints of the CSP
csp4x4 = {}
csp4x4['variables'] = ['1,1', '1,2', '1,3', '1,4', '2,1', '2,2', '2,3', '2,4',
                       '3,1', '3,2', '3,3', '3,4', '4,1', '4,2', '4,3', '4,4']
csp4x4['domains'] = { '1,1':{1,2,3,4}, '1,2':{1,2,3,4}, '1,3':{1,2,3,4}, '1,4':{1,2,3,4},
                      '2,1':{1,2,3,4}, '2,2':{1,2,3,4}, '2,3':{1,2,3,4}, '2,4':{1,2,3,4},
                      '3,1':{1,2,3,4}, '3,2':{1,2,3,4}, '3,3':{1,2,3,4}, '3,4':{1,2,3,4},
                      '4,1':{1,2,3,4}, '4,2':{1,2,3,4}, '4,3':{1,2,3,4}, '4,4':{1,2,3,4}}
csp4x4['constraints'] = constraints4x4  

# Sets a CSP for the 9x9 board as well. Only the variables are defined directly below while the
# domains and constraints are generated by the following functions
csp9x9 = {}                                                                                             
csp9x9['variables'] = [('1,1'),('1,2'),('1,3'), ('1,4'),('1,5'),('1,6'), ('1,7'),('1,8'),('1,9'),     
                       ('2,1'),('2,2'),('2,3'), ('2,4'),('2,5'),('2,6'), ('2,7'),('2,8'),('2,9'),
                       ('3,1'),('3,2'),('3,3'), ('3,4'),('3,5'),('3,6'), ('3,7'),('3,8'),('3,9'),
                       ('4,1'),('4,2'),('4,3'), ('4,4'),('4,5'),('4,6'), ('4,7'),('4,8'),('4,9'),
                       ('5,1'),('5,2'),('5,3'), ('5,4'),('5,5'),('5,6'), ('5,7'),('5,8'),('5,9'),
                       ('6,1'),('6,2'),('6,3'), ('6,4'),('6,5'),('6,6'), ('6,7'),('6,8'),('6,9'),
                       ('7,1'),('7,2'),('7,3'), ('7,4'),('7,5'),('7,6'), ('7,7'),('7,8'),('7,9'),
                       ('8,1'),('8,2'),('8,3'), ('8,4'),('8,5'),('8,6'), ('8,7'),('8,8'),('8,9'),
                       ('9,1'),('9,2'),('9,3'), ('9,4'),('9,5'),('9,6'), ('9,7'),('9,8'),('9,9')]

# Generate all possible domains for each cell - assuming a blank initial board
def initialize_domains(size):   
    initial_domain = set(range(1, size + 1))                # each cell has a domain of 1-9
    domains = {}
    for row in range(1, size + 1):
        for col in range(1, size + 1):
            domains[f"{row},{col}"] = set(initial_domain)   # set each cell's domain to be the initial domain
    return domains

domains9x9 = initialize_domains(9)
csp9x9['domains'] = domains9x9     # add the domains to the dict for the 9x9 CSP 

# Generate the constraints for each cell provided the size of the board. The constraints define what value
# each cell can take with respect to the other cells in the same row, column, and subgrid
def generate_constraints9x9(size):
    constraints = {}

    # iterate through each cell in the grid
    for i in range(1, size + 1):
        for j in range(1, size + 1):
            key1 = (str(i),str(j))
            key1 = ((f'{i},{j}'))
            neighbors = []

            # add row neighbors 
            for k in range(1, size + 1):
                if k != j:
                    neighbors.append((f'{i},{k}'))

            # add column neighbors 
            for k in range(1, 10):
                if k != i:
                    neighbors.append((f'{k},{j}'))

            # add subgrid neighbors 
            box_row = (i - 1) // 3
            box_col = (j - 1) // 3
            for m in range(box_row * 3 + 1, box_row * 3 + 4):
                for n in range(box_col * 3 + 1, box_col * 3 + 4):
                    if m != i and n != j:
                        neighbors.append((f'{m},{n}'))
            
            each_constraint = [('1,2'), ('1,3'), ('1,4'), ('1,5'), ('1,6'), ('1,7'), ('1,8'), ('1,9'),
                      ('2,1'), ('2,3'), ('2,4'), ('2,5'), ('2,6'), ('2,7'), ('2,8'), ('2,9'), 
                      ('3,1'), ('3,2'), ('3,4'), ('3,5'), ('3,6'), ('3,7'), ('3,8'), ('3,9'), 
                      ('4,1'), ('4,2'), ('4,3'), ('4,5'), ('4,6'), ('4,7'), ('4,8'), ('4,9'), 
                      ('5,1'), ('5,2'), ('5,3'), ('5,4'), ('5,6'), ('5,7'), ('5,8'), ('5,9'), 
                      ('6,1'), ('6,2'), ('6,3'), ('6,4'), ('6,5'), ('6,7'), ('6,8'), ('6,9'),
                      ('7,1'), ('7,2'), ('7,3'), ('7,4'), ('7,5'), ('7,6'), ('7,8'), ('7,9'), 
                      ('8,1'), ('8,2'), ('8,3'), ('8,4'), ('8,5'), ('8,6'), ('8,7'), ('8,9'), 
                      ('9,1'), ('9,2'), ('9,3'), ('9,4'), ('9,5'), ('9,6'), ('9,7'), ('9,8') ]
                        
            for neighbor in neighbors: # for the current cell (key1) and each neighbor set the constraints
                constraints[key1,neighbor] = each_constraint 

    return constraints

constraints9x9 = generate_constraints9x9(9) 
csp9x9['constraints'] = constraints9x9

## Part 2 : Revise Function 
#           Takes a CSP and the name of two variables (cells) and removes any value in the first value's domain
#           when there isn't a corresponding value in the second variable's domain
#           Returns True if revised, False otherwise

# to speed up by revise function, I generate a list of the general constraint pairs as a tuple for comparison in revise
csp9x9['constraint_pairs'] = [tuple(map(int, pair.split(','))) for pair in constraints9x9['1,1','1,2']]

def revise(csp, xi, xj):
    revised = False
    x1_domain = list(csp['domains'][xi])
    x2_domain = list(csp['domains'][xj])
    
    for x in x1_domain:  # iterate through Xi's domains
        satisfied = False
        for y in x2_domain:  # iterate through Xj's domain
            # if check_pair_in_constraint(x,y,constraint_pairs):  # if the constraints can be met with (x, y)
            if (x,y) in csp9x9['constraint_pairs']:  # if the constraints can be met with (x, y)
                satisfied = True
                break
        if not satisfied:  # if the constraint between Xi and Xj cannot be satisfied with value x
            csp['domains'][xi].remove(x)
            revised = True
    return revised

## Part 3 : AC-3
#           Takes a CSP and removes any inconsistent values across all domains
#           Returns True is all variables have at least one value in their domain, False otherwise
def ac3(csp):
    queue = deque()
        
    for key in csp['constraints']:
        queue.append(key)   # add each constraint (arc) to the queue
    
    while queue:
        xi, xj = queue.popleft() # grab a pair from the queue
        if revise(csp, xi, xj):  # check if the domain of xi changes
            if len(csp['domains'][xi]) == 0:
                return False  # return False if a domain is empty - not a solution
            
            for xi, xk in csp['constraints'].keys(): # add all neighbors of Xi to the queue
                if xk != xj:
                    queue.append((xk, xi))
    return True  # return true other wise - all variables have domain size >= 1


## Part 4 : Minimum Remaining Values (Heuristic) 
#           Takes a CSP and a set of assignments 
#           Returns a variable with the smallest number of values in its domain (besides assigned cells)
def minimum_remaining_values(csp, assignments: dict):
    min_size = float('inf') # largest possible domain size
    min_var = None
    
    domains = csp['domains']
    variables = csp['variables']
    for var in variables:   # iterate through each variable (cell)
        if var not in assignments:  # check only if the variable has not been assigned yet (meaning the domain size is > 1)
            domain_size = len(domains[var]) # store the domain size
            if domain_size < min_size:  # if this domain size is smaller than the current minimum size, return the variable
                min_size = domain_size  # & store new miminimum domain size
                min_var = var   
                
    return min_var

## Part 5 : Backtracking Search
#           Takes a CSP, a set of assignments, 
#           Returns the solution (assignment of each cell), the order in which they were assigned and the remaining unassigned variables

# checks the constraints for the provided cell (var) with each of it's neighbors to see if it is valid to set the cell to the provided value
# returns True if consistent, False otherwise
def consistent(csp, assignments, value, variable):
    pairs = csp['constraints'].keys()
    for pair in pairs: 
        if pair[0] == variable and pair[1] in assignments: # find only pairs containing the variable and looking at only it's assigned neighbors
            cell_neighbor = pair[1] 
            if cell_neighbor in assignments and value == assignments[cell_neighbor]:
                return False  
    return True
        
def backtrack(csp, assignments: dict, order: list[dict], guesses, failed_vals) -> Tuple[dict, list[dict]]:
    variables: dict = csp['variables']
    domains: dict = csp['domains']
    constraints: dict = csp['constraints']

    if len(assignments) == len(variables):  # each cell has an assignment = puzzle is solved !! 
        return [assignments, order]
    
    cell_to_change = minimum_remaining_values(csp, assignments)  # select a variable to change
    
    if len(domains[cell_to_change]) > 1:
        guesses += 1    # track the number of guesses being made
    
    for possible_value in csp['domains'][cell_to_change]:  # iterate through possible values for the variable
        if consistent(csp, assignments, cell_to_change, possible_value):  # check if assigning this possible_value would be consistent
            # copy because we might modify the domains
            prev_domains = deepcopy(domains)

            assignments[cell_to_change] = possible_value  # assign to possible_value
            domains[cell_to_change] = {possible_value}
            keep = deepcopy(order[-1])
            if cell_to_change == failed_vals[0]:
                keep[cell_to_change] = (failed_vals[1] + str(possible_value))
            else:
                keep[cell_to_change] = (str(possible_value))
            order.append(keep)
            
            if ac3(csp):  # check if the graph is still arc-consistent with the guess

                result = backtrack(csp, assignments, order, guesses, [cell_to_change,  str(possible_value)])  # continue to the next guess
                if result:
                    return result # if backtrack returns a solution, the puzzle is solved - return assignments
                order.pop()

            # Part 5 : FANCY - store the values that failed and so it then needed to backtrack
            failed_vals = [cell_to_change, str(possible_value) + '\u0336 ']  # store the values that don't work out
            
            # possible value is not valid, so set everything back to the previous state
            del assignments[cell_to_change]
            domains = prev_domains
            
            csp['domains'] = domains
            csp['constraints'] = constraints
            csp['variables'] = variables
              
    return False

def solve_puzzle(csp, assignments=None):
        
    domains: dict = csp['domains']
    order: list[set] = [{}]
    
    if assignments is None:
        assignments = {}
    
    for variable in assignments: # set the domains to be equal to the provided assignments
        domains[variable] = {assignments[variable]}
        order[0][variable] = (str(assignments[variable]))
        
    # run AC-3 and backtracking algorithms
    if ac3(csp):
        return backtrack(csp, assignments, order, 1, [None, None])
    else:
        return False

# -----------------------------------------------------------------------------------------------------------------
# Solve the 9x9 CSP using Puzzle 1 as provided assignments

[assignments_final, solve_loops] = solve_puzzle(csp9x9, assignments1)

print('Assignments (in the order they were set): ', assignments_final)

# Iterate over X, Y coordinates to print the final board in the correct orientation
print('\nFinal Board Solution: ')
for x in range(1, 10):
    for y in range(1, 10):
        # Construct the key as a string
        key = f"{x},{y}"
        
        value = assignments_final.get(key, "Empty")  # Default value if key not found
        value_str = str(value) 
        print(value_str.ljust(5), end=" ")  # Adjust padding as needed
    print()  # Move to the next line after printing each row
    
print(csp9x9['domains'])




